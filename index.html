<!DOCTYPE html>
<html>
	<head>
		<meta charset=utf-8>
		<title>MyGame</title>
		<style>
			body { margin: 0; }
			canvas { width: 100%; height: 100% }
		</style>
	</head>
	<body>
		<script src="js/three.js"></script>
		<script src="js/func.js"></script>
		<script>
			var scene = new THREE.Scene();
			var width = window.innerWidth;
			var height = window.innerHeight;
			// Orthographic, Keeping near at .1, as close as possible
			var camera = new THREE.OrthographicCamera( width / -2, width / 2, height / 2, height / -2, .1, 1000.0 );
			camera.lookAt(new THREE.Vector3(0,0,1));

			var renderer = new THREE.WebGLRenderer();
			renderer.setSize( window.innerWidth, window.innerHeight );
			renderer.setClearColor(0xffffff, 1.0);
			document.body.appendChild( renderer.domElement );

			collidableMeshList = [];
			// Making bars
			collidableMeshList = collidableMeshList.concat(makeSideBars(scene));
			collidableMeshList = collidableMeshList.concat(genFloor(scene));
			var platform = genPlatform(scene);
			collidableMeshList = collidableMeshList.concat(platform);
			var water = genWater(scene);
			var character = genCharacter(scene);
			character.position.x = width/4;
			character.position.y = height;
			
			var darknessFilter = genDarknessFilter(scene, 0);
			var airMovementSpeed = 5;
			var waterMovementSpeed = 3;
			var characterWaterAccel = -0.01;
			var characterAirAccel = -0.2;
			var characterVelo = 0;

			var torchDirection = 0;

			var map = {}; // You could also use an array
			onkeydown = onkeyup = function(e){
			    e = e || event; // to deal with IE
			    map[e.keyCode] = e.type == 'keydown';
			    if(map[37]){
			    	e.preventDefault();

			    	if(onPlatform(character,platform)){ move(character, collidableMeshList,airMovementSpeed, 0);}
			    	if (isInWater){ move(character, collidableMeshList, waterMovementSpeed, 0); }
			    	torchDirection = 0;
			    }
			    if(map[38]){
			    	e.preventDefault(); 
			    	if(onPlatform(character,platform)){ characterVelo = 5; }
			    	if(isInWater){ characterVelo =0;move(character, collidableMeshList, waterMovementSpeed, 1); }
			    	if(!isInWater){move(character, collidableMeshList, airMovementSpeed, 1);}
			    	torchDirection = 1.5*Math.PI;

			    }
			    if(map[39]){
			    	e.preventDefault(); 
			    	if(isInWater){ move(character, collidableMeshList, -waterMovementSpeed, 2); }
			    	else{ move(character, collidableMeshList, -airMovementSpeed, 2);}
			    	
			    	torchDirection = Math.PI;
			    }
			    if(map[40]){
			    	e.preventDefault(); 
			    	
			    	if (isInWater){ move(character, collidableMeshList, -waterMovementSpeed, 3); }
			    	else{ move(character, collidableMeshList, -airMovementSpeed, 3);}
			    	torchDirection = 0.5*Math.PI;
			    }

			    if(map[37] && map[38]){
			    	torchDirection = 1.75*Math.PI;
			    }
			    if(map[38] && map[39]){
			    	torchDirection = 1.25*Math.PI;
			    }
			    if(map[39] && map[40]){
			    	torchDirection = 0.75*Math.PI;
			    }
			    if(map[40] && map[37]){
			    	torchDirection = 0.25*Math.PI;
			    }

			}
			/*document.addEventListener("keydown", function(e){
				switch(e.keyCode) {
					// move(character, movementSpeed, collidableMeshList, 0);
					case 37: e.preventDefault(); move(character, collidableMeshList, movementSpeed, 0);  break;
					case 38: e.preventDefault(); characterVelo = 0; move(character, collidableMeshList, movementSpeed, 1); break;
					case 39: e.preventDefault(); move(character, collidableMeshList, movementSpeed, 2); break;
					case 40:  break;
				}
			}, false);*/



			//camera.position.z = 5;
			var firstBB;
			var secondBB;
			var isInWater = false;
			//var isOnPlatform = fasle;

			var animate = function () {
				requestAnimationFrame( animate );

				//cube.rotation.x += 0.1;
				//cube.rotation.y += 0.1;
				if(inWater(character, water)){
					characterVelo += characterWaterAccel;
					if(!isInWater){
						characterVelo *= 0.1;
					}
					isInWater = true;
				}
				else{
					characterVelo += characterAirAccel;
					if(isInWater){
						
					}
					isInWater = false;
				}
				//characterVelo += characterWaterAccel;
				if(onPlatform(character,platform) && characterVelo > 0){
					move(character, collidableMeshList, characterVelo, 3, 1);
					//characterVelo-=0.05;
				}
				move(character, collidableMeshList, characterVelo, 3);
				//console.log(characterVelo);
				

				//console.log(character.position);
				//console.log(water.position);
				/*for(var i = 0;i<collidableMeshList.length;i++) {
					firstBB = new THREE.Box3().setFromObject(collidableMeshList[i]);
					secondBB = new THREE.Box3().setFromObject(character);

					var collision = firstBB.intersectsBox(secondBB);

					if((firstBB.getCenter().x - secondBB.getCenter().x)>0) {
						lockCharLeft[3] = true; //Locking left motion
					}
					if((firstBB.getCenter().x - secondBB.getCenter().x)<0) {
						lockCharLeft[2] = true; //locking right motion
					}
					if((firstBB.getCenter().y - secondBB.getCenter().y)>0) {
						lockCharLeft[0] = true; //Locking upward motion
					}
					if((firstBB.getCenter().y - secondBB.getCenter().y)<0) {
						lockCharLeft[1] = true; //Locking downward motion
					}
				}
				

				
				if(collision) lockCharLeft = 0;
				else lockCharLeft = 1;*/

				darknessFilter.position.x = character.position.x;
				darknessFilter.position.y = character.position.y;
				// console.log(torchDirection);

				darknessFilter.rotation.z = 0.8*darknessFilter.rotation.z-0.2*torchDirection;

				renderer.render(scene, camera);
			};

			animate();
		</script>
	</body>
</html>